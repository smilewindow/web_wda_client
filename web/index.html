<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WDA Web 控制台</title>
  <style>
    :root { --bg:#0b0b0c; --fg:#e7e7e9; --panel:#16161a; --line:#2a2a2f; --accent:#4da3ff; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    #wrap{display:flex;justify-content:center;align-items:center;min-height:100%}
    #phone{position:relative;border-radius:16px;overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,.45);background:#000}
    /* 让画面自适应窗口，高度受限避免被遮挡（HUD/工具栏预留约 160px） */
    #stream{display:block;max-width:92vw;max-height:calc(100vh - 160px);width:auto;height:auto;background:#000}
    #overlay{position:absolute;left:0;top:0;pointer-events:auto}
    .cursor{position:absolute;width:10px;height:10px;border-radius:50%;background:var(--accent);box-shadow:0 0 0 3px rgba(77,163,255,.25);pointer-events:none;opacity:.9;transform:translate(-9999px,-9999px)}
    #hud{position:fixed;left:12px;top:12px;background:rgba(22,22,26,.75);backdrop-filter:saturate(1.2) blur(6px);border:1px solid var(--line);border-radius:12px;padding:8px 10px;display:flex;gap:10px;align-items:center}
    #toolbar{position:fixed;left:12px;bottom:12px;display:flex;gap:8px;flex-wrap:wrap}
    .btn{padding:8px 12px;background:var(--panel);border:1px solid var(--line);border-radius:10px;cursor:pointer}
    .btn:active{transform:translateY(1px)}
    .pill{padding:4px 8px;border:1px solid var(--line);border-radius:999px;background:var(--panel);font-size:12px}
    .muted{opacity:.8}
    #appium-panel{position:fixed;right:12px;bottom:12px;width:min(360px,92vw);background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px;display:none}
    #appium-panel h4{margin:0 0 8px 0;font-size:14px}
    #appium-panel .row{display:flex;align-items:center;gap:8px;margin:6px 0}
    #appium-panel input[type="text"]{flex:1 1 auto;padding:6px 8px;border:1px solid var(--line);border-radius:8px;background:#0f0f12;color:var(--fg)}
    #appium-panel input[type="range"]{flex:1 1 auto}
    #appium-panel .val{width:36px;text-align:right;opacity:.8}
    .toast{position:fixed;right:12px;top:64px;max-width:min(480px,92vw);background:rgba(22,22,26,.95);border:1px solid var(--line);border-radius:10px;padding:10px 12px;color:var(--fg);box-shadow:0 6px 20px rgba(0,0,0,.35);z-index:9999}
    .toast.ok{border-color:#2d6a2d}
    .toast.err{border-color:#8a2b2b}
    .toast .title{font-weight:600;margin-right:8px}
    .toast .close{margin-left:10px;cursor:pointer;opacity:.8}
    #gest-toggle{position:fixed;right:12px;top:12px;padding:6px 10px;border:1px solid var(--line);border-radius:999px;background:var(--panel);color:var(--fg);cursor:pointer;z-index:10000}
    #gest-panel{position:fixed;right:12px;top:52px;width:min(460px,92vw);max-height:70vh;display:none;flex-direction:column;background:var(--panel);border:1px solid var(--line);border-radius:12px;z-index:9999}
    #gest-panel header{display:flex;gap:8px;align-items:center;padding:8px 10px;border-bottom:1px solid var(--line)}
    #gest-panel header input[type="number"]{width:88px;padding:4px 6px;border:1px solid var(--line);border-radius:8px;background:#0f0f12;color:var(--fg)}
    #gest-panel .body{padding:6px 8px;display:flex;flex-direction:column;gap:8px}
    #gest-log{font:12px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;max-height:38vh;overflow:auto;white-space:pre-wrap;background:#0f0f12;border:1px solid var(--line);border-radius:8px;padding:6px}
    #gest-panel .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    #gest-panel .g-sec-head{display:flex;align-items:center;justify-content:space-between;gap:8px}

    /* Gesture status panel (sample-like) */
    .g-kv{display:grid;grid-template-columns:auto 1fr;gap:6px 10px;padding:6px}
    .g-pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#10233a;border:1px solid #20314b;color:#9fb5d8;font-size:12px}
    .g-section h3{margin:6px 0 4px 2px;font-size:13px;opacity:.9}
    .g-help{font-size:12px;opacity:.9;border:1px solid var(--line);border-radius:8px;padding:6px;background:#0f0f12}
  </style>
</head>
<body>
  <div id="hud">
    <span class="pill" id="hud-api">API: <code class="muted"></code></span>
    <span class="pill" id="hud-size">—</span>
  </div>

  <div id="wrap">
    <div id="phone">
      <img id="stream" alt="iPhone Stream" />
      <canvas id="overlay"></canvas>
      <div class="cursor" id="cursor"></div>
    </div>
  </div>

  <div id="toolbar">
    <button class="btn" id="btn-home">Home</button>
    <button class="btn" id="btn-lock">Lock</button>
    <button class="btn" id="btn-vol-up">Vol +</button>
    <button class="btn" id="btn-vol-down">Vol −</button>
    <button class="btn" id="btn-reload">重载</button>
    <button class="btn" id="btn-appium">Appium 设置</button>
  </div>

  <button id="gest-toggle">手势日志</button>
  <div id="gest-panel">
    <header>
      <label><input type="checkbox" id="gest-debug"/> 调试日志</label>
      <label><input type="checkbox" id="gest-dryrun"/> 仅日志（不发送）</label>
      <div class="row">
        <label for="gest-lp" class="muted">长按(ms)</label>
        <input id="gest-lp" type="number" min="200" max="5000" step="100" />
      </div>
      <div class="row">
        <label for="gest-hz" class="muted">Pump Hz</label>
        <input id="gest-hz" type="number" min="10" max="120" step="5" />
      </div>
      <div class="row">
        <label for="gest-step" class="muted">步长(pt)</label>
        <input id="gest-step" type="number" min="0.2" max="10" step="0.1" />
      </div>
      <div class="row">
        <label for="gest-intensity" class="muted">甩动力度</label>
        <select id="gest-intensity" style="padding:4px 6px;border:1px solid var(--line);border-radius:8px;background:#0f0f12;color:var(--fg)">
          <option value="light">轻</option>
          <option value="medium">中</option>
          <option value="strong">强</option>
        </select>
      </div>
      <!-- 移除 press 持续时间设置，交由算法自适应 -->
      <button id="gest-close" class="btn">关闭</button>
    </header>
    <div class="body">
      <div class="g-section">
        <h3>运行状态</h3>
        <div class="g-kv">
          <div>模式</div><div><span class="g-pill" id="g-mode">idle</span></div>
          <div>拖拽注入</div><div><span class="g-pill" id="g-dragMode">appium(one-shot)</span></div>
          <div>映射</div><div><span class="g-pill" id="g-mapping">px→pt (auto)</span></div>
        </div>
      </div>
      <div class="g-section">
        <h3>阈值 / 参数</h3>
        <div class="g-help" id="g-help">
          • tap: 按下→抬起 < 250ms 且位移 < 8px
          • longPress: 按住 ≥ 3000ms 且位移 < 8px（可在面板调整）
          • drag/swipe: 位移 ≥ 8px；swipe 需 <= 250ms
          • DragPump: 默认 30Hz，将 last→target 切段注入，时长≈33ms
          • 坐标映射：根据设备 pt/px 自动换算
        </div>
      </div>
      <div class="g-section">
        <div class="g-sec-head"><h3 style="margin:6px 0 4px 2px">事件日志</h3><button id="gest-clear" class="btn">清空</button></div>
        <div id="gest-log"></div>
      </div>
    </div>
  </div>

  <div id="appium-panel">
    <h4>Appium MJPEG 设置</h4>
    <div class="row">
      <label style="width:74px">Base</label>
      <input type="text" id="ap-base" placeholder="http://127.0.0.1:4723"/>
    </div>
    <div class="row">
      <label style="width:74px">Session</label>
      <input type="text" id="ap-sid" placeholder="<Appium SessionId>"/>
    </div>
    <div class="row">
      <label style="width:74px">UDID</label>
      <input type="text" id="ap-udid" placeholder="<Device UDID for create>"/>
    </div>
    <div class="row">
      <label style="width:74px">缩放%</label>
      <input type="range" min="30" max="100" step="1" id="ap-scale"/>
      <span class="val" id="ap-scale-val"></span>
    </div>
    <div class="row">
      <label style="width:74px">帧率</label>
      <input type="range" min="10" max="60" step="1" id="ap-fps"/>
      <span class="val" id="ap-fps-val"></span>
    </div>
    <div class="row">
      <label style="width:74px">质量</label>
      <input type="range" min="5" max="50" step="1" id="ap-quality"/>
      <span class="val" id="ap-quality-val"></span>
    </div>
    <div class="row">
      <label style="width:74px">动画冷却</label>
      <select id="ap-aco" style="flex:1 1 auto;padding:6px 8px;border:1px solid var(--line);border-radius:8px;background:#0f0f12;color:var(--fg)">
        <option value="0">0.0</option>
        <option value="0.1">0.1</option>
        <option value="0.2">0.2</option>
      </select>
    </div>
    <!-- 手势通道选择已移除：前端固定走 Appium 通道 -->
    <!-- 保活设置移除，默认总是保活（见脚本） -->

    <div class="row" style="justify-content:flex-end;gap:10px;flex-wrap:wrap">
      <button class="btn" id="ap-fetch">获取会话</button>
      <button class="btn" id="ap-create">创建会话</button>
      <button class="btn" id="ap-load">读取设置</button>
      <button class="btn" id="ap-optimize">WDA 优化</button>
      <button class="btn" id="ap-apply">应用</button>
      <button class="btn" id="ap-close">关闭</button>
    </div>
    <div class="row" style="font-size:12px;opacity:.8">提示：需使用 Appium 的会话 ID；若有 base 变更，请在此填写。</div>
  </div>

  <script>
    // ─────────────────────────────────────────────────────────────────────
    // 基础配置：自动推断 API（可用 ?api= 替换），默认同主机 7000 端口
    // ─────────────────────────────────────────────────────────────────────
    function getParam(name){const u=new URL(location.href);return u.searchParams.get(name)}
    function hostWithBracket(host){
      // 对 IPv6 字面量加方括号，避免形成 http://::1:7000 这类非法 URL
      return (host.includes(':') && !host.startsWith('[')) ? `[${host}]` : host;
    }
    const API = getParam('api') || (location.protocol === 'file:' || !location.hostname
      ? 'http://127.0.0.1:7000'
      : `${location.protocol}//${hostWithBracket(location.hostname)}:7000`);
    const HUD_API = document.querySelector('#hud-api code');
    HUD_API.textContent = API;

    const img = document.getElementById('stream');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');

    const hudSize = document.getElementById('hud-size');

    // 已移除直连 WDA 的 WebSocket 手势通道，前端仅走 Appium 通道。

    // 设备尺寸（pt 与 px），用于坐标映射
    let devicePt = { w:null, h:null };
    let devicePx = { w:null, h:null };

    // 轻量通知与包装请求 + 手势调试面板
    // 调试日志默认关闭：只显示高层手势（tap/press/drag/swipe）
    let GEST_LOG = (localStorage.getItem('gest.debug')||'0') === '1';
    let DRYRUN = (localStorage.getItem('gest.dryrun')||'0') === '1'; // 1=仅日志，不发送控制请求
    const logBox = document.getElementById('gest-log');
    function appendGestLog(obj){
      try{
        const ts = new Date().toLocaleTimeString();
        const line = typeof obj === 'string' ? obj : JSON.stringify(obj);
        const el = document.createElement('div');
        el.textContent = `[${ts}] ${line}`;
        if (!logBox) return;
        // 是否贴底（仅在贴底时自动滚动，避免用户手动上滚被打断）
        const nearBottom = (logBox.scrollTop + logBox.clientHeight) >= (logBox.scrollHeight - 4);
        logBox.appendChild(el);
        while (logBox.children.length > 300) logBox.removeChild(logBox.firstChild);
        if (nearBottom) logBox.scrollTop = logBox.scrollHeight;
      }catch(_e){}
    }
    // 事件日志：总是打印（tap/press/drag/swipe/longPress 等）
    function ev(type, payload){
      const line = `${type}${payload?': '+JSON.stringify(payload):''}`;
      appendGestLog(line);
      try{ console.log('[GEST]', line); }catch(_e){}
    }
    // 调试日志：仅在面板勾选“调试日志”时打印（move/down/up/fetch/pinch 等）
    const log = (...a)=>{
      if(!GEST_LOG) return;
      try{ console.log('[GEST]', ...a); }catch(_e){}
      appendGestLog(a.length===1 ? a[0] : a.map(x=>typeof x==='string'?x:JSON.stringify(x)).join(' '));
    };
    function syncGestPanel(){
      const p = document.getElementById('gest-panel');
      const cbDbg = document.getElementById('gest-debug');
      const cbDry = document.getElementById('gest-dryrun');
      const ipLP = document.getElementById('gest-lp');
      const ipHz = document.getElementById('gest-hz');
      const ipStep = document.getElementById('gest-step');
      const ipIntensity = document.getElementById('gest-intensity');
      if (!p) return;
      if (cbDbg){ cbDbg.checked = GEST_LOG; cbDbg.onchange = ()=>{ GEST_LOG = cbDbg.checked; localStorage.setItem('gest.debug', GEST_LOG?'1':'0'); }; }
      if (cbDry){ cbDry.checked = DRYRUN; cbDry.onchange = ()=>{ DRYRUN = cbDry.checked; localStorage.setItem('gest.dryrun', DRYRUN?'1':'0'); }; }
      if (ipLP){
        const def = 3000;
        ipLP.value = String(Number(localStorage.getItem('gest.longpress.ms')||def));
        ipLP.onchange = ()=>{ const v = Math.max(200, Math.min(5000, Number(ipLP.value)||def)); localStorage.setItem('gest.longpress.ms', String(v)); ipLP.value = String(v); };
      }
      if (ipHz){ ipHz.value = String(getPumpHz()); ipHz.onchange = ()=>{ const v = Math.max(10, Math.min(120, Number(ipHz.value)||30)); localStorage.setItem('gest.pump.hz', String(v)); ipHz.value = String(v); updatePumpPill(); if (pump && typeof pump.setHz==='function') pump.setHz(v); }; }
      if (ipStep){ ipStep.value = String(getPumpStep()); ipStep.onchange = ()=>{ const v = Math.max(0.2, Math.min(10, Number(ipStep.value)||1.5)); localStorage.setItem('gest.pump.step', String(v)); ipStep.value = String(v); updatePumpPill(); if (pump && typeof pump.setMinStep==='function') pump.setMinStep(v); }; }
      // 已移除 press 时长设置
      if (ipIntensity){
        const def = (localStorage.getItem('gest.flick.intensity')||'medium');
        ipIntensity.value = (['light','medium','strong'].includes(def) ? def : 'medium');
        ipIntensity.onchange = ()=>{ const v = String(ipIntensity.value||'medium'); localStorage.setItem('gest.flick.intensity', v); };
      }
      const btnClear = document.getElementById('gest-clear'); if (btnClear) btnClear.onclick = ()=>{ if (logBox) logBox.innerHTML=''; };
      const btnClose = document.getElementById('gest-close'); if (btnClose) btnClose.onclick = ()=>{ p.style.display = 'none'; };
    }
    const gestToggle = document.getElementById('gest-toggle');
    if (gestToggle){
      gestToggle.onclick = ()=>{ const p = document.getElementById('gest-panel'); if (!p) return; p.style.display = (p.style.display==='none' || !p.style.display) ? 'flex' : 'none'; syncGestPanel(); };
    }
    function toast(msg, type='err', ttl=3200){
      try{
        const el = document.createElement('div');
        el.className = 'toast ' + (type==='ok'?'ok':'err');
        el.innerHTML = `<span class="title">${type==='ok'?'提示':'错误'}</span><span class="msg"></span><span class="close">✕</span>`;
        el.querySelector('.msg').textContent = ' ' + String(msg);
        el.querySelector('.close').onclick = ()=>{ try{ document.body.removeChild(el);}catch(e){} };
        document.body.appendChild(el);
        setTimeout(()=>{ try{ document.body.removeChild(el);}catch(e){} }, ttl);
      }catch(_e){ alert(msg); }
    }

    function getGestureChannel(){ return 'appium'; }
    function getAppiumBaseAndSid(){
      return { base: (localStorage.getItem('ap.base')||'').trim(), sid: (localStorage.getItem('ap.sid')||'').trim() };
    }
    async function tapAt(x,y){
      log('tapAt', { ch:'wda', x, y });
      if (DRYRUN){ log('DRYRUN tap skip send'); return; }
      await safeFetch(API + '/api/tap', {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ x, y })
      }, '点击');
    }
    async function longPressAt(x,y, durationMs){
      const durMs = Math.max(200, Math.round(durationMs||600));
      log('longPressAt', { ch:'appium', x, y, durationMs: durMs });
      if (DRYRUN){ log('DRYRUN long-press skip send'); return; }
      const { base, sid } = getAppiumBaseAndSid();
      if (!base || !sid){ toast('Appium 通道需要已配置 Base 与 Session', 'err'); return; }
      await mobileExec('mobile: touchAndHold', { x: Math.round(x), y: Math.round(y), duration: durMs/1000 }, '长按');
    }

    async function safeFetch(url, opts, actionLabel){
      const isExec = typeof url === 'string' && url.indexOf('/api/appium/exec-mobile') >= 0;
      const isWdaTap = typeof url === 'string' && url.indexOf('/api/tap') >= 0;
      let scriptName = '';
      try{ if (isExec && opts && typeof opts.body === 'string'){ const b = JSON.parse(opts.body||'{}'); scriptName = String(b.script||''); } }catch(_e){}
      const t0 = performance.now();
      try{
        log('fetch', actionLabel, url, opts);
        const r = await fetch(url, opts);
        const ms = Math.round(performance.now() - t0);
        if (isExec){ ev('req', { script: scriptName||'(unknown)', ms, status: r.status }); }
        else if (isWdaTap){ ev('req', { script: 'wda: tap', ms, status: r.status }); }
        if(!r.ok){
          let txt = '';
          try{ txt = await r.text(); }catch(_e){}
          let brief = '';
          try{ const j = JSON.parse(txt); brief = j.error || txt; }catch(_e){ brief = txt; }
          const hint = r.status===503 ? '（未检测到 WDA 会话，右下角“Appium 设置”创建或启用后端 WDA_AUTO_CREATE）' : '';
          toast(`[${actionLabel}] 失败 (${r.status})：` + (brief||'') + hint, 'err');
        }
        return r;
      }catch(err){
        const ms = Math.round(performance.now() - t0);
        if (isExec){ ev('req', { script: scriptName||'(unknown)', ms, error: String(err) }); }
        else if (isWdaTap){ ev('req', { script: 'wda: tap', ms, error: String(err) }); }
        log('fetch-error', actionLabel, err);
        toast(`[${actionLabel}] 网络错误：` + err, 'err');
        throw err;
      }
    }
    async function mobileExec(script, args, label){
      const { base, sid } = getAppiumBaseAndSid();
      if (!base || !sid){ toast('Appium 通道需要已配置 Base 与 Session', 'err'); return; }
      if (MOBILE_BUSY){ toast('上一个操作未完成，请稍后', 'err'); return; }
      MOBILE_BUSY = true;
      try{
        await safeFetch(API + '/api/appium/exec-mobile', {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ base, sessionId: sid, script, args })
        }, label);
      } finally {
        MOBILE_BUSY = false;
      }
    }

    // 交互状态（由 DragPump + interact.js 驱动）
    let isDown = false;
    let downAt = 0;
    let downClient = {x:0,y:0};
    const modePill = document.getElementById('g-mode');
    const dragModePill = document.getElementById('g-dragMode');
    const mappingPill = document.getElementById('g-mapping');
    const cursorEl = document.getElementById('cursor');
    let pump = null;
    let MOBILE_BUSY = false; // Appium exec-mobile 并发闸门
    function setMode(text){ if(modePill) modePill.textContent = text; }
    function getPumpHz(){ const v = Number(localStorage.getItem('gest.pump.hz')||30); return Math.max(10, Math.min(120, isFinite(v)?v:30)); }
    function getPumpStep(){ const v = Number(localStorage.getItem('gest.pump.step')||1.5); return Math.max(0.2, Math.min(10, isFinite(v)?v:1.5)); }
    function updatePumpPill(){ if (dragModePill) dragModePill.textContent = 'appium(one-shot)'; }
    // 计算 Appium 拖拽参数：基于屏幕高度自适应
    function getFlickIntensity(){
      const v = String(localStorage.getItem('gest.flick.intensity')||'medium');
      return (v==='light'||v==='strong') ? v : 'medium';
    }
    function flickCoeff(){ // 依据力度给出速度系数（×H）
      const m = { light: 1.6, medium: 1.9, strong: 2.2 };
      return m[getFlickIntensity()] || 1.9;
    }
    function calcAppiumDragArgs(from, to, durMs){
      const { sx, sy } = getPxScale();
      const dx2 = (to.x - from.x) * sx; const dy2 = (to.y - from.y) * sy;
      const dist_px = Math.hypot(dx2, dy2);
      const dur_s = Math.max(0.001, (durMs||0)/1000);
      const H = Number(devicePx.h||0) || img.naturalHeight || 1920;

      const FLICK_TIME_MS = 250;
      const FLICK_MIN_DIST_RATIO = 0.06; // 6% 屏高
      const isFlick = (durMs <= FLICK_TIME_MS) && (dist_px >= FLICK_MIN_DIST_RATIO * H);

      const v_min = 0.6 * H;
      const v_max = 2.2 * H;
      const v_flick = flickCoeff() * H;
      const v_small = 1.2 * H;

      let velocity;
      if (dist_px < 0.02 * H || dur_s < 0.06) {
        velocity = v_small;
      } else if (isFlick) {
        velocity = v_flick;
      } else {
        const v_est = dist_px / Math.max(0.03, dur_s);
        velocity = Math.max(v_min, Math.min(v_max, v_est));
      }

      let press = isFlick ? 0.04 : 0.09; // 秒
      press = Math.max(0.03, Math.min(0.15, press));

      // 慢拖&短距离 → 认为是“拖放”，给少量 hold 提升成功率
      let hold = 0.0;
      if (dur_s > 0.6 && (dist_px / H) < 0.3) {
        hold = 0.10;
      }

      return {
        pressDuration: press,
        holdDuration: hold,
        velocity: Math.round(velocity)
      };
    }

    // 判定是否为 flick
    function isFlick(from, to, durMs){
      const { sx, sy } = getPxScale();
      const dx2 = (to.x - from.x) * sx; const dy2 = (to.y - from.y) * sy;
      const dist_px = Math.hypot(dx2, dy2);
      const H = Number(devicePx.h||0) || img.naturalHeight || 1920;
      const FLICK_TIME_MS = 250;
      const FLICK_MIN_DIST_RATIO = 0.06; // 6% 屏高
      return (durMs <= FLICK_TIME_MS) && (dist_px >= FLICK_MIN_DIST_RATIO * H);
    }
    // 不再使用 swipe，统一用 dragFromToWithVelocity
    function getPxScale(){
      const sx = (devicePt.w && devicePx.w) ? (devicePx.w / devicePt.w) : 1;
      const sy = (devicePt.h && devicePx.h) ? (devicePx.h / devicePt.h) : sx;
      return { sx, sy };
    }
    updatePumpPill();
    mappingPill && (mappingPill.textContent = 'tap→/api/tap(WDA) · longPress→mobile: touchAndHold · drag(flick/drag)→mobile: dragFromToWithVelocity');

    async function fetchDeviceInfo(){
      try{
        const r = await fetch(API + '/api/device-info');
        if(!r.ok){
          let t = '';
          try{ t = await r.text(); }catch(_e){}
          let msg = '';
          try{ const j = JSON.parse(t); msg = j.error||t; }catch(_e){ msg = t; }
          const hint = r.status===503 ? '未检测到 WDA 会话，请在右下角“Appium 设置”创建会话，或启用后端 WDA_AUTO_CREATE=true。' : '获取设备信息失败。';
          toast(hint + (msg?`（${msg.slice(0,200)}）`:''), 'err');
          return;
        }
        const j = await r.json();
        if (j.size_pt) devicePt = { w:j.size_pt.w, h:j.size_pt.h };
        if (j.size_px) devicePx = { w:j.size_px.w, h:j.size_px.h };
        hudSize.textContent = `pt ${devicePt.w||'-'}×${devicePt.h||'-'} | px ${devicePx.w}×${devicePx.h}`;
        resizeOverlay();
      }catch(err){ toast('获取设备信息失败：' + err, 'err'); }
    }

    // 让 overlay 与 <img> 渲染后的尺寸吻合
    function resizeOverlay(){
      let rect = img.getBoundingClientRect();
      let left = img.offsetLeft, top = img.offsetTop, w = rect.width, h = rect.height;
      if (!w || !h){
        // 当流未就绪时回退到父容器或窗口尺寸，保证可接收指针事件
        const host = document.getElementById('phone') || img.parentElement || document.body;
        const r2 = host.getBoundingClientRect();
        w = r2.width || Math.min(window.innerWidth * 0.6, 480);
        h = r2.height || Math.min(window.innerHeight - 160, 800);
        left = host.offsetLeft || 0; top = host.offsetTop || 0;
        rect = { left, top, width: w, height: h, right: left + w, bottom: top + h };
      }
      canvas.width = w; canvas.height = h;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      canvas.style.left = left + 'px';
      canvas.style.top = top + 'px';
    }

    // 画面上坐标 → 设备坐标（优先 pt，退化到 px）
    function toDevicePt(clientX, clientY){
      const rect = img.getBoundingClientRect();
      const xOnImg = clientX - rect.left;
      const yOnImg = clientY - rect.top;
      const basisW = devicePt.w || devicePx.w || rect.width;
      const basisH = devicePt.h || devicePx.h || rect.height;
      const scaleX = basisW / rect.width;
      const scaleY = basisH / rect.height;
      return { x: xOnImg * scaleX, y: yOnImg * scaleY, rect };
    }

    // 简单的指示点（CSS cursor）
    function drawDot(x,y){
      cursorEl.style.transform = `translate(${Math.round(x-5)}px, ${Math.round(y-5)}px)`;
    }

    // 使用 interact.js 统一处理 down/move/up（tap/long-press/drag）
    let longPressTriggered = false; let longHoldStart = 0; let pressTimer = null;
    let chAtDown = 'appium'; let ptDown = null; let dragStarted = false;

    // 适配器（仍沿用名称），内部仅走 Appium 通道
    class WDAAdapter {
      constructor(){ }
      async tap(pt){
        // 统一走 tapAt（现仅 Appium 通道）
        return tapAt(pt.x, pt.y);
      }
      async longPress(pt, durationMs){
        // 统一走 longPressAt，自动按通道选择实现
        const dur = Math.max(200, Math.round(durationMs||600));
        return longPressAt(pt.x, pt.y, dur);
      }
      async drag(from, to, durationMs, meta={}){
        const durSec = Math.max(0.03, (durationMs||80)/1000);
        const dx = (to.x - from.x), dy = (to.y - from.y);
        const dist = Math.hypot(dx, dy);
        const speed = dist / durSec; // pt/s
        const seq = (meta && typeof meta.seq==='number') ? meta.seq : undefined;
        ev('drag@pump', { seq, from, to, durationMs: Math.round(durSec*1000), speed: Math.round(speed) });
        // 仅保留 Appium 通道。拖拽由抬起时一次性发送（见交互逻辑）。
        if (GEST_LOG) log('[pump] segment ignored (appium-only mode)');
        return;
      }
    }

    class DragPump {
      constructor(adapter, { hz=30, minStep=1.5 }={}){
        this.adapter = adapter; this.hz = hz; this.dt = 1000/hz; this.minStep = minStep;
        this.active = false; this.last = null; this.target = null; this.timer = null; this.seq = 0;
      }
      setHz(hz){ this.hz = Math.max(1, Number(hz)||30); this.dt = 1000/this.hz; }
      setMinStep(v){ this.minStep = Math.max(0.1, Number(v)||1.5); }
      start(at){ this.active = true; this.last = at; this.target = at; this.seq = 0; this._loop(); }
      move(to){ this.target = to; }
      stop(){ this.active = false; }
      _loop(){
        const tick = async ()=>{
          if (!this.active) return;
          const t0 = performance.now();
          if (this.last && this.target){
            const dx = this.target.x - this.last.x; const dy = this.target.y - this.last.y;
            const d2 = dx*dx + dy*dy;
            if (d2 >= this.minStep*this.minStep){
              try{ void this.adapter.drag(this.last, this.target, this.dt, { seq: this.seq++ }).catch(()=>{}); }
              catch(_e){}
              this.last = this.target;
            }
          }
          const el = performance.now() - t0;
          const wait = Math.max(0, this.dt - el);
          this.timer = setTimeout(tick, wait);
        };
        this.timer = setTimeout(tick, this.dt);
      }
    }
    function getLongPressMs(){ const v = Number(localStorage.getItem('gest.longpress.ms')||3000); return Math.max(200, isFinite(v)?v:3000); }
    function setupInteractHandlers(){
      if (typeof interact === 'undefined') { console.warn('[GEST] interact.js not ready'); return; }
      try{
        const adapter = new WDAAdapter();
        pump = new DragPump(adapter, { hz: getPumpHz(), minStep: getPumpStep() });
        let useHTTPPump = false; // 本次拖拽是否回退到 HTTP 泵
        interact(canvas)
        .on('down', (e)=>{
          log('down', { x:e.clientX, y:e.clientY, ch: 'appium' });
          isDown = true; downAt = performance.now();
          const {x,y} = toDevicePt(e.clientX, e.clientY);
          downClient = {x:e.clientX, y:e.clientY};
          longPressTriggered = false; longHoldStart = performance.now(); dragStarted = false;
          chAtDown = 'appium'; ptDown = {x,y};
          try{ if (pressTimer) clearTimeout(pressTimer); }catch(_e){}
          pressTimer = setTimeout(()=>{
            if (!isDown || dragStarted) return;
            const dx = e.clientX - downClient.x; const dy = e.clientY - downClient.y;
            if ((dx*dx + dy*dy) <= 64) {
              longPressTriggered = true;
              setMode('longPress');
              ev('longPress', { at: {x:ptDown.x,y:ptDown.y}, durationMs: getLongPressMs() });
              void adapter.longPress({x:ptDown.x,y:ptDown.y}, getLongPressMs());
            }
          }, getLongPressMs());
          cursorEl && (cursorEl.style.transform = `translate(${e.clientX - img.getBoundingClientRect().left - 5}px, ${e.clientY - img.getBoundingClientRect().top - 5}px)`);
          setMode('pressing');
        })
        .on('move', (e)=>{
          log('move', { x:e.clientX, y:e.clientY, isDown, dragStarted, longPressTriggered });
          if (!isDown) return;
          const p = toDevicePt(e.clientX, e.clientY);
          const dx = e.clientX - downClient.x; const dy = e.clientY - downClient.y; const dist2 = dx*dx + dy*dy;
          if (!dragStarted && dist2 > 64 && !longPressTriggered){
            try{ if (pressTimer) clearTimeout(pressTimer); }catch(_e){}
            dragStarted = true;
            setMode('dragging(pump)');
            // 不打印 move / drag-start，仅在结束时打印 drag/swipe（分段日志由 pump 内部打印）
          }
          // Appium 通道：移动阶段不发送请求，抬起时一次性执行 mobile: dragFromToWithVelocity
          drawDot(e.clientX - p.rect.left, e.clientY - p.rect.top);
        })
        .on('up', (e)=>{
          log('up', { x:e.clientX, y:e.clientY, isDown, dragStarted, longPressTriggered });
          if (!isDown) return; isDown = false;
          try{ if (pressTimer) clearTimeout(pressTimer); }catch(_e){}
          const p = toDevicePt(e.clientX, e.clientY);
          if (dragStarted){
            // Appium 通道：仅更新状态，事件日志在发送请求处统一记录
            const endDur = performance.now() - downAt;
            const kind = endDur <= 250 ? 'swipe' : 'drag';
            setMode(kind + '(end)');
          }

          const dx = e.clientX - downClient.x;
          const dy = e.clientY - downClient.y;
          const dist2 = dx*dx + dy*dy;
          const dur = performance.now() - downAt;
          if (longPressTriggered){
            // 已在定时器中触发长按，这里不重复
          } else if (dist2 <= 64 && dur <= 250) {
            setMode('tap');
            ev('tap', { at: {x:p.x, y:p.y} });
            void (new WDAAdapter()).tap({x:p.x, y:p.y});
          } else if (chAtDown === 'appium') {
            const from = ptDown || {x:p.x,y:p.y};
            const { base, sid } = getAppiumBaseAndSid();
            if (!base || !sid){ toast('Appium 通道需要已配置 Base 与 Session', 'err'); }
            else {
              const argsDyn = calcAppiumDragArgs(from, {x:p.x,y:p.y}, dur);
              const args = {
                pressDuration: argsDyn.pressDuration,
                holdDuration: argsDyn.holdDuration,
                fromX: Math.round(from.x), fromY: Math.round(from.y),
                toX: Math.round(p.x), toY: Math.round(p.y),
                velocity: argsDyn.velocity,
              };
              if (DRYRUN){ log('DRYRUN drag skip send', { from, to:{x:p.x,y:p.y}, ...args }); }
              else {
                if (MOBILE_BUSY){ toast('上一个操作未完成，请稍后', 'err'); }
                else { MOBILE_BUSY = true; safeFetch(API + '/api/appium/exec-mobile', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ base, sessionId: sid, script: 'mobile: dragFromToWithVelocity', args }) }, '拖拽').finally(()=>{ MOBILE_BUSY = false; }); }
              }
              ev(isFlick(from, {x:p.x,y:p.y}, dur) ? 'drag(flick)' : 'drag', { from, to:{x:p.x,y:p.y}, durationMs: Math.round(dur), velocity: args.velocity });
            }
          }

          // 底部上滑 → Home
          const rect = p.rect; const startY = downClient.y - rect.top; const endY = e.clientY - rect.top;
          const isFromBottom = startY > rect.height * 0.92;
          const movedUpEnough = (startY - endY) > rect.height * 0.12;
          if (isFromBottom && movedUpEnough) {
            if (DRYRUN){ log('DRYRUN home swipe'); }
            else { void safeFetch(API + '/api/pressButton', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name:'home'}) }, 'Home'); }
          }

          // 清理指示点
          // 保留 cursor 位置不清屏，提升跟手感
        });
      }catch(err){ console.warn('[GEST] interact setup error', err); }
    } 

    // 双击 ≈ 双击触发两次 tap（iOS 无系统级 doubleTap 端点）
    canvas.addEventListener('dblclick', (e)=>{
      const p = toDevicePt(e.clientX, e.clientY);
      const adapter = new WDAAdapter();
      void adapter.tap({x:p.x, y:p.y});
      setTimeout(()=>{ void adapter.tap({x:p.x, y:p.y}); }, 80);
    });

    // 不再手动映射 touch→mouse，交由 interact.js 统一处理
    // 但为兼容 CDN 不可用的情况，提供原生指针事件后备
    function setupNativeHandlers(){
      try{
        const adapter = new WDAAdapter();
        pump = new DragPump(adapter, { hz: getPumpHz(), minStep: getPumpStep() });
        let useHTTPPump = false;
        const onDown = (e)=>{
          log('down*', { x:e.clientX, y:e.clientY, ch: 'appium' });
          isDown = true; downAt = performance.now();
          const {x,y} = toDevicePt(e.clientX, e.clientY);
          downClient = {x:e.clientX, y:e.clientY};
          longPressTriggered = false; longHoldStart = performance.now(); dragStarted = false;
          chAtDown = 'appium'; ptDown = {x,y};
          try{ if (pressTimer) clearTimeout(pressTimer); }catch(_e){}
          pressTimer = setTimeout(()=>{
            if (!isDown || dragStarted) return;
            const dx = e.clientX - downClient.x; const dy = e.clientY - downClient.y;
            if ((dx*dx + dy*dy) <= 64) {
              longPressTriggered = true;
              setMode('longPress');
              ev('longPress', { at: {x:ptDown.x,y:ptDown.y}, durationMs: getLongPressMs() });
              void adapter.longPress({x:ptDown.x,y:ptDown.y}, getLongPressMs());
            }
          }, getLongPressMs());
          cursorEl && (cursorEl.style.transform = `translate(${e.clientX - img.getBoundingClientRect().left - 5}px, ${e.clientY - img.getBoundingClientRect().top - 5}px)`);
          setMode('pressing');
        };
        const onMove = (e)=>{
          log('move*', { x:e.clientX, y:e.clientY, isDown, dragStarted, longPressTriggered });
          if (!isDown) return;
          const p = toDevicePt(e.clientX, e.clientY);
          const dx = e.clientX - downClient.x; const dy = e.clientY - downClient.y; const dist2 = dx*dx + dy*dy;
          if (!dragStarted && dist2 > 64 && !longPressTriggered){
            try{ if (pressTimer) clearTimeout(pressTimer); }catch(_e){}
            dragStarted = true;
            setMode('dragging(pump)');
          }
          // Appium 通道：移动阶段不发送请求
          drawDot(e.clientX - p.rect.left, e.clientY - p.rect.top);
        };
        const onUp = (e)=>{
          log('up*', { x:e.clientX, y:e.clientY, isDown, dragStarted, longPressTriggered });
          if (!isDown) return; isDown = false;
          try{ if (pressTimer) clearTimeout(pressTimer); }catch(_e){}
          const p = toDevicePt(e.clientX, e.clientY);
          if (dragStarted){
            // Appium 通道：仅更新状态，事件日志在发送请求处统一记录
            const endDur = performance.now() - downAt;
            const kind = endDur <= 250 ? 'swipe' : 'drag';
            setMode(kind + '(end)');
          }
          const dx = e.clientX - downClient.x; const dy = e.clientY - downClient.y; const dist2 = dx*dx + dy*dy;
          const dur = performance.now() - downAt;
          if (longPressTriggered){ /* already sent */ }
          else if (dist2 <= 64 && dur <= 250) {
            setMode('tap'); ev('tap', { at: {x:p.x, y:p.y} }); void (new WDAAdapter()).tap({x:p.x, y:p.y});
          } else if (chAtDown === 'appium') {
            const from = ptDown || {x:p.x,y:p.y};
            const { base, sid } = getAppiumBaseAndSid();
            if (!base || !sid){ toast('Appium 通道需要已配置 Base 与 Session', 'err'); }
            else {
              if (DRYRUN){
                const argsEst = calcAppiumDragArgs(from, {x:p.x,y:p.y}, dur);
                log('DRYRUN drag skip send', { from, to:{x:p.x,y:p.y}, ...argsEst });
              } else {
                const argsDyn = calcAppiumDragArgs(from, {x:p.x,y:p.y}, dur);
                const args = { pressDuration: argsDyn.pressDuration, holdDuration: argsDyn.holdDuration, fromX: Math.round(from.x), fromY: Math.round(from.y), toX: Math.round(p.x), toY: Math.round(p.y), velocity: argsDyn.velocity };
                if (MOBILE_BUSY){ toast('上一个操作未完成，请稍后', 'err'); }
                else { MOBILE_BUSY = true; safeFetch(API + '/api/appium/exec-mobile', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ base, sessionId: sid, script: 'mobile: dragFromToWithVelocity', args }) }, '拖拽').finally(()=>{ MOBILE_BUSY = false; }); }
              }
              ev(isFlick(from, {x:p.x,y:p.y}, dur) ? 'drag(flick)' : 'drag', { from, to:{x:p.x,y:p.y}, durationMs: Math.round(dur) });
            }
          }

          // 底部上滑 → Home（与 interact 实现一致）
          const rect = p.rect; const startY = downClient.y - rect.top; const endY = e.clientY - rect.top;
          const isFromBottom = startY > rect.height * 0.92;
          const movedUpEnough = (startY - endY) > rect.height * 0.12;
          if (isFromBottom && movedUpEnough) {
            if (DRYRUN){ log('DRYRUN home swipe'); }
            else { void safeFetch(API + '/api/pressButton', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name:'home'}) }, 'Home'); }
          }
        };
        canvas.addEventListener('pointerdown', onDown);
        canvas.addEventListener('pointermove', onMove);
        canvas.addEventListener('pointerup', onUp);
        canvas.addEventListener('pointercancel', onUp);
      }catch(err){ console.warn('[GEST] native setup error', err); }
    }

    // 顶部按钮
    document.getElementById('btn-home').onclick = ()=>{ void safeFetch(API + '/api/pressButton', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name:'home'})}, 'Home'); };
    document.getElementById('btn-lock').onclick = ()=>{ void safeFetch(API + '/api/pressButton', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name:'lock'})}, '锁屏'); };
    document.getElementById('btn-vol-up').onclick = ()=>{ void safeFetch(API + '/api/pressButton', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name:'volumeUp'})}, '音量+'); };
    document.getElementById('btn-vol-down').onclick = ()=>{ void safeFetch(API + '/api/pressButton', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name:'volumeDown'})}, '音量-'); };
    let streamToastShown = false;
    document.getElementById('btn-reload').onclick = ()=>{
      // 重新加载流并刷新设备尺寸
      img.src = API + '/stream' + '#' + Math.random();
      fetchDeviceInfo();
    };

    // Appium 设置面板
    const panel = document.getElementById('appium-panel');
    const apBase = document.getElementById('ap-base');
    const apSid = document.getElementById('ap-sid');
    const apScale = document.getElementById('ap-scale');
    const apFps = document.getElementById('ap-fps');
    const apQuality = document.getElementById('ap-quality');
    const apUdid = document.getElementById('ap-udid');
    const apAco = document.getElementById('ap-aco');
    const apScaleVal = document.getElementById('ap-scale-val');
    const apFpsVal = document.getElementById('ap-fps-val');
    const apQualityVal = document.getElementById('ap-quality-val');

    function loadAppiumPrefs(){
      apBase.value = localStorage.getItem('ap.base') || 'http://127.0.0.1:4723';
      apSid.value = localStorage.getItem('ap.sid') || '';
      apScale.value = localStorage.getItem('ap.scale') || 60;
      apFps.value = localStorage.getItem('ap.fps') || 30;
      apQuality.value = localStorage.getItem('ap.quality') || 15;
      apUdid.value = localStorage.getItem('ap.udid') || '';
      apAco.value = String(localStorage.getItem('ap.aco') || '0.1');
      apScaleVal.textContent = apScale.value;
      apFpsVal.textContent = apFps.value;
      apQualityVal.textContent = apQuality.value;
    }
    loadAppiumPrefs();

    apScale.oninput = ()=> apScaleVal.textContent = apScale.value;
    apFps.oninput = ()=> apFpsVal.textContent = apFps.value;
    apQuality.oninput = ()=> apQualityVal.textContent = apQuality.value;

    document.getElementById('btn-appium').onclick = ()=>{
      loadAppiumPrefs();
      panel.style.display = 'block';
    };
    document.getElementById('ap-close').onclick = ()=> panel.style.display = 'none';
    // 手势通道固定为 Appium，无需下拉与存储
    document.getElementById('ap-apply').onclick = async ()=>{
      const base = apBase.value.trim();
      const sid = apSid.value.trim();
      const settings = {
        mjpegScalingFactor: Number(apScale.value),
        mjpegServerFramerate: Number(apFps.value),
        mjpegServerScreenshotQuality: Number(apQuality.value),
        shouldWaitForQuiescence: false,
        waitForIdleTimeout: 0,
        animationCoolOffTimeout: Number(apAco.value)
      };
      localStorage.setItem('ap.base', base);
      localStorage.setItem('ap.sid', sid);
      localStorage.setItem('ap.udid', apUdid.value.trim());
      localStorage.setItem('ap.scale', String(settings.mjpegScalingFactor));
      localStorage.setItem('ap.fps', String(settings.mjpegServerFramerate));
      localStorage.setItem('ap.quality', String(settings.mjpegServerScreenshotQuality));
      localStorage.setItem('ap.aco', String(settings.animationCoolOffTimeout));
      try{
        const r = await fetch(API + '/api/appium/settings', {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ base, sessionId: sid, settings })
        });
        if(!r.ok){
          const t = await r.text();
          toast('应用失败: ' + t.slice(0,400), 'err');
        }else{
          toast('已应用设置', 'ok');
          streamToastShown = false;
          img.src = API + '/stream?' + Date.now();
          fetchDeviceInfo();
          panel.style.display = 'none';
        }
      }catch(err){
        toast('网络错误: ' + err, 'err');
      }
    };

    document.getElementById('ap-fetch').onclick = async ()=>{
      const base = apBase.value.trim();
      if(!base){ alert('请先填写 Appium Base'); return; }
      try{
        // 先尝试获取最近一次在本后端创建的会话
        let r = await fetch(API + '/api/appium/last-session?base=' + encodeURIComponent(base));
        let j = await r.json();
        if (j.ok && j.sessionId) {
          apSid.value = j.sessionId;
          localStorage.setItem('ap.sid', apSid.value);
          toast('已获取会话: ' + apSid.value, 'ok');
          streamToastShown = false;
          img.src = API + '/stream?' + Date.now();
          fetchDeviceInfo();
          return;
        }
        // 回退尝试 /sessions（部分 Appium v2 不支持，可能为空）
        r = await fetch(API + '/api/appium/sessions?base=' + encodeURIComponent(base));
        j = await r.json();
        if(j.sessions && j.sessions.length){
          apSid.value = j.sessions[j.sessions.length - 1];
          localStorage.setItem('ap.sid', apSid.value);
          toast('已获取会话: ' + apSid.value, 'ok');
          streamToastShown = false;
          img.src = API + '/stream?' + Date.now();
          fetchDeviceInfo();
        } else {
          toast('未发现会话，请创建', 'err');
        }
      }catch(err){ toast('获取失败: ' + err, 'err'); }
    };

    document.getElementById('ap-create').onclick = async ()=>{
      const base = apBase.value.trim();
      const udid = apUdid.value.trim();
      if(!base || !udid){ toast('请填写 Base 与 UDID', 'err'); return; }
      try{
        const r = await fetch(API + '/api/appium/create', {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ base, udid, wdaLocalPort:8100, mjpegServerPort:9100, bundleId:'com.apple.Preferences', noReset:true, extraCaps: {
            'appium:shouldWaitForQuiescence': false,
            'appium:waitForIdleTimeout': 0,
            'appium:animationCoolOffTimeout': Number(apAco.value),
            'appium:showXcodeLog': true,
            'appium:showIOSLog': false,
            'appium:logTimestamps': true
          } })
        });
        const j = await r.json();
        if(r.ok && j.sessionId){
          apSid.value = j.sessionId;
          localStorage.setItem('ap.sid', apSid.value);
          localStorage.setItem('ap.udid', udid);
          toast('会话已创建: ' + j.sessionId, 'ok');
          streamToastShown = false;
          img.src = API + '/stream?' + Date.now();
          fetchDeviceInfo();
        }else{
          toast('创建失败: ' + JSON.stringify(j).slice(0,400), 'err');
        }
      }catch(err){ toast('创建失败: ' + err, 'err'); }
    };

    document.getElementById('ap-load').onclick = async ()=>{
      const base = apBase.value.trim();
      const sid = apSid.value.trim();
      if(!base || !sid){ toast('请填写 Base 与 Session', 'err'); return; }
      try{
        const r = await fetch(API + '/api/appium/settings?base=' + encodeURIComponent(base) + '&sessionId=' + encodeURIComponent(sid));
        const j = await r.json();
        if(!r.ok){
          toast('读取失败: ' + JSON.stringify(j).slice(0,400), 'err');
          return;
        }
        const val = j.value || j; // 兼容不同返回结构
        if(typeof val.mjpegScalingFactor === 'number') apScale.value = val.mjpegScalingFactor;
        if(typeof val.mjpegServerFramerate === 'number') apFps.value = val.mjpegServerFramerate;
        if(typeof val.mjpegServerScreenshotQuality === 'number') apQuality.value = val.mjpegServerScreenshotQuality;
        apScaleVal.textContent = apScale.value;
        apFpsVal.textContent = apFps.value;
        apQualityVal.textContent = apQuality.value;
        localStorage.setItem('ap.scale', apScale.value);
        localStorage.setItem('ap.fps', apFps.value);
        localStorage.setItem('ap.quality', apQuality.value);
        toast('已读取当前设置', 'ok');
      }catch(err){ toast('读取失败: ' + err, 'err'); }
    };

    // 一键下发 WDA 优化设置：useFirstMatch / snapshotMaxDepth / activeAppDetectionPoint / reduceMotion
    document.getElementById('ap-optimize').onclick = async ()=>{
      const base = apBase.value.trim();
      const sid = apSid.value.trim();
      if(!base || !sid){ toast('请填写 Base 与 Session', 'err'); return; }
      const settings = {
        useFirstMatch: true,
        snapshotMaxDepth: 20,
        activeAppDetectionPoint: '200.00,200.00',
        reduceMotion: true
      };
      try{
        const r = await fetch(API + '/api/appium/settings', {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ base, sessionId: sid, settings })
        });
        if(!r.ok){
          const t = await r.text();
          toast('WDA 优化失败: ' + t.slice(0,400), 'err');
        }else{
          toast('WDA 优化已下发', 'ok');
        }
      }catch(err){ toast('网络错误: ' + err, 'err'); }
    };

    // 初始加载
    img.src = API + '/stream?' + Date.now();
    img.onload = ()=> resizeOverlay();
    img.onerror = ()=> { console.warn('[stream] failed to load:', img.src); if(!streamToastShown){ toast('画面流连接失败：请检查 MJPEG 是否可用（环境变量 MJPEG 需指向有效流，常见为 9100）。', 'err'); streamToastShown = true; } };
    window.onresize = ()=> resizeOverlay();
    // 跟随鼠标显示指示点
    canvas.addEventListener('pointermove', (e)=>{
      const rect = img.getBoundingClientRect();
      drawDot(e.clientX - rect.left, e.clientY - rect.top);
    });
    window.addEventListener('load', ()=>{
      const base0 = localStorage.getItem('ap.base')||'';
      const sid0 = localStorage.getItem('ap.sid')||'';
      if (base0 && sid0) {
        apBase.value = base0; apSid.value = sid0;
      }
    });
    fetchDeviceInfo();

    
  </script>
  <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
  <script>
    // 仅在 Appium 手势通道下启用捏合（pinch）识别，并映射到 mobile: pinch
    (function(){
      if (typeof interact === 'undefined') { try{ setupNativeHandlers(); }catch(_e){} return; }
      try { setupInteractHandlers(); } catch(_e) {}
      const target = canvas;
      let pinchActive = false; let pinchLastScale = 1; let pinchCenter = null;
      try{
        interact(target).gesturable({
          listeners: {
            start (ev){
              log('pinch start', { x: ev.clientX, y: ev.clientY });
              pinchActive = true; pinchLastScale = 1;
              const c = toDevicePt(ev.clientX, ev.clientY);
              pinchCenter = { x: c.x, y: c.y };
            },
            move (ev){
              if (!pinchActive) return;
              if (typeof ev.scale === 'number' && isFinite(ev.scale)) {
                pinchLastScale = ev.scale; // 相对起点比例
              }
              log('pinch move', { scale: ev.scale });
            },
            end (ev){
              if (!pinchActive) return; pinchActive = false;
              log('pinch end', { scale: pinchLastScale, center: pinchCenter });
              const { base, sid } = getAppiumBaseAndSid();
              if (!base || !sid) { toast('Appium 通道需要已配置 Base 与 Session', 'err'); return; }
              // 合理裁剪 scale，避免过大/过小
              let scale = pinchLastScale; if (!isFinite(scale) || scale === 0) scale = 1;
              scale = Math.max(0.5, Math.min(2.0, scale));
              const args = { x: Math.round(pinchCenter?.x || 0), y: Math.round(pinchCenter?.y || 0), scale, velocity: 1.0 };
              if (DRYRUN){ log('DRYRUN pinch skip send', { args }); return; }
              void safeFetch(API + '/api/appium/exec-mobile', {
                method:'POST', headers:{'Content-Type':'application/json'},
                body: JSON.stringify({ base, sessionId: sid, script: 'mobile: pinch', args })
              }, '捏合');
            }

          }
        });
      }catch(_e){ /* ignore */ }
    })();
  </script>
</body>
</html>
