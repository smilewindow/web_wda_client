import asyncio
import contextlib
import os
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional
from urllib.parse import urlencode, urlparse

import core


FFMPEG_BIN = os.environ.get("FFMPEG_BIN", "ffmpeg")
RTMP_BASE = os.environ.get(
    "RTMP_PUSH_BASE", "rtmp://127.0.0.1:1935/iphone").rstrip("/")
RTMP_USER = os.environ.get("RTMP_PUSH_USER", "encoder")
RTMP_PASS = os.environ.get("RTMP_PUSH_PASS", "s3cret")
ENABLE_PUSH = os.environ.get("ENABLE_STREAM_PUSH", "true").lower() in {
    "1", "true", "yes", "y"}
_FFMPEG_LOG_LEVEL = os.environ.get("FFMPEG_LOG_LEVEL", "info").lower()


_STREAM_READER_LIMIT = 4 * 1024 * 1024  # 4MB
_STREAM_READ_CHUNK = 64 * 1024
_STREAM_LOG_MAX_SEGMENT = 512 * 1024


class _StreamState:
    __slots__ = ("process", "task")

    def __init__(self, process: asyncio.subprocess.Process, task: asyncio.Task):
        self.process = process
        self.task = task


def _build_ffmpeg_log_flags() -> list[str]:
    """ÊûÑÂª∫FFmpegÊó•ÂøóÁ∫ßÂà´Ê†áÂøó"""
    log_flags = []

    # Ê∑ªÂä†ËØ¶ÁªÜÁöÑÊó•ÂøóÁ∫ßÂà´
    if _FFMPEG_LOG_LEVEL in {"debug", "trace", "verbose"}:
        log_flags.extend(["-loglevel", _FFMPEG_LOG_LEVEL])
        log_flags.extend(["-v", _FFMPEG_LOG_LEVEL])

    # ÂØπ‰∫étraceÁ∫ßÂà´ÔºåÊ∑ªÂä†Êõ¥ËØ¶ÁªÜÁöÑË∞ÉËØï‰ø°ÊÅØ
    if _FFMPEG_LOG_LEVEL in {"trace", "verbose"}:
        log_flags.extend(["-report"])  # ÁîüÊàêÊä•ÂëäÊñá‰ª∂
        log_flags.extend(["-stats"])   # ÊòæÁ§∫ÁºñÁ†ÅÁªüËÆ°
        log_flags.extend(["-benchmark"])  # ÊÄßËÉΩÂü∫ÂáÜÊµãËØï

    # Ê∑ªÂä†Á°¨‰ª∂Âä†ÈÄüË∞ÉËØï‰ø°ÊÅØ
    if _FFMPEG_LOG_LEVEL in {"debug", "trace"}:
        log_flags.extend(["-hwaccels"])  # ÊòæÁ§∫ÂèØÁî®ÁöÑÁ°¨‰ª∂Âä†ÈÄüÂô®
        log_flags.extend(["-filters"])  # ÊòæÁ§∫ÂèØÁî®Êª§Èïú

    return log_flags


_STREAMS: Dict[str, _StreamState] = {}
_LOCK = asyncio.Lock()


async def start_stream(udid: str, session_id: str, base_url: str, mjpeg_port: int) -> Optional[str]:
    if not ENABLE_PUSH:
        core.logger.info("Stream push disabled; skip ffmpeg launch")
        return None

    input_url = _build_mjpeg_url(base_url, mjpeg_port)
    output_url = f"{RTMP_BASE}/{udid}/{session_id}"
    credentials = {"user": RTMP_USER, "pass": RTMP_PASS}
    # ÂÖÅËÆ∏ÈÄöËøáÁΩÆÁ©∫Áî®Êà∑Âêç/ÂØÜÁ†ÅÊù•Ë∑≥ËøáËøΩÂä†Âá≠ËØÅ
    if credentials["user"] or credentials["pass"]:
        query = urlencode(credentials)
        output_url = output_url + ("&" if "?" in output_url else "?") + query

    log_flags = _build_ffmpeg_log_flags()

    # cmd = [
    #     FFMPEG_BIN,
    #     "-hide_banner",
    #     "-fflags", "+nobuffer+genpts+discardcorrupt",
    #     "-use_wallclock_as_timestamps", "1",
    #     "-reconnect", "1",
    #     "-reconnect_streamed", "1",
    #     "-reconnect_at_eof", "1",
    #     "-reconnect_on_network_error", "1",
    #     "-reconnect_delay_max", "5",
    #     "-rw_timeout", "60000000",
    #     "-seekable", "0",
    #     "-thread_queue_size", "1024",
    #     "-f", "mjpeg",
    #     "-i", input_url,
    #     "-init_hw_device", "videotoolbox=vt",
    #     "-filter_hw_device", "vt",
    #     "-vf", "fps=25,zscale=rangein=full:range=limited:matrix=bt709,format=nv12,hwupload,scale_vt=720:1560",
    #     "-c:v", "h264_videotoolbox",
    #     "-profile:v", "main",
    #     "-realtime", "1",
    #     "-b:v", "2500k",
    #     "-maxrate", "3000k",
    #     "-bufsize", "5000k",
    #     "-g", "50",
    #     "-color_range", "tv",
    #     "-color_primaries", "bt709",
    #     "-color_trc", "bt709",
    #     "-colorspace", "bt709",
    #     "-rtmp_live", "live",
    #     "-rtmp_buffer", "100",
    #     "-flvflags", "no_duration_filesize",
    #     "-an",
    #     "-f", "flv",
    #     output_url,
    # ]

    cmd = [
        FFMPEG_BIN,
        # ÂèñÊ∂àËæìÂÖ•ÁºìÂÜ≤ÔºåÈôç‰ΩéÊï¥‰ΩìÂª∂Ëøü
        "-fflags", "nobuffer",
        # ‰ΩøÁî®Á≥ªÁªüÊó∂Èíü‰Ωú‰∏∫Êó∂Èó¥Êà≥Ôºå‰øùÊåÅÂÆûÊó∂ÊÄß
        "-use_wallclock_as_timestamps", "1",
        # ËØªÂèñË∂ÖÊó∂ËÆæÁΩÆ‰∏∫ 10 Áßí
        "-rw_timeout", "10000000",  # 10 second timeout
        # ÊâìÂºÄÊñ≠Á∫øÈáçËøûÂºÄÂÖ≥
        "-reconnect", "1",
        # ÈíàÂØπÊµÅÂ™í‰Ωì‰∏éÁΩëÁªúÈîôËØØÂêØÁî®ÈáçËøû
        "-reconnect_streamed", "1",
        # ÊåáÂÆöËæìÂÖ•‰∏∫ MJPEG
        "-f", "mjpeg",
        # MJPEG ËæìÂÖ•Âú∞ÂùÄ
        "-i", input_url,
        # ‰ΩøÁî®È´òË¥®ÈáèÁº©ÊîæÁÆóÊ≥ïÂíåÂÆåÊï¥Ëâ≤Â∫¶Â§ÑÁêÜ
        "-sws_flags", "lanczos+accurate_rnd+full_chroma_int",
        # ËßÜÈ¢ëÊª§ÈïúÔºöÈôêÂà∂25fps„ÄÅÁº©ÊîæËá≥720ÂÆΩ„ÄÅPCËΩ¨TVËâ≤ÂΩ©ËåÉÂõ¥„ÄÅËΩ¨Êç¢‰∏∫YUV420Ê†ºÂºè
        "-vf", "fps=30,scale=720:-2,scale=in_range=pc:out_range=tv,format=yuv420p",
        # ‰ΩøÁî®ËΩØ‰ª∂H.264ÁºñÁ†ÅÂô®
        "-c:v", "libx264",
        # ÁºñÁ†ÅÈ¢ÑËÆæÔºöÈÄüÂ∫¶‰ºòÂÖàÔºåÁâ∫Áâ≤‰∏ÄÂÆöÁîªË¥®Êç¢Âèñ‰ΩéÂª∂Ëøü
        "-preset", "veryfast",
        # Èõ∂Âª∂ËøüË∞É‰ºòÔºö‰ºòÂåñÁºñÁ†ÅÂèÇÊï∞‰ª•Èôç‰ΩéÂª∂Ëøü
        "-tune", "zerolatency",
        # ‰ΩøÁî®HighÈÖçÁΩÆÊñá‰ª∂ÔºåÊèêÈ´òÂéãÁº©ÊïàÁéá
        "-profile:v", "high",
        # GOPÈïøÂ∫¶50Â∏ßÔºàÁ∫¶2ÁßíÔºâ
        "-g", "60",
        # x264ÁºñÁ†ÅÂô®ÂèÇÊï∞ÔºöÂÖ≥Èó≠BÂ∏ß„ÄÅÂõ∫ÂÆöGOPÈïøÂ∫¶
        "-x264-params", "bframes=0:keyint=50:min-keyint=50",
        # Ë¥®ÈáèÂõ†Â≠ê18ÔºåÈ´òË¥®ÈáèËÆæÁΩÆÔºàÊï∞ÂÄºË∂ä‰ΩéË¥®ÈáèË∂äÂ•ΩÔºâ
        "-crf", "18",
        # Ëâ≤ÂΩ©ËåÉÂõ¥ÔºöTVËåÉÂõ¥Ôºà16-235Ôºâ
        "-color_range", "tv",
        # Ëâ≤ÂΩ©ÂéüËâ≤ÔºöBT.709Ê†áÂáÜ
        "-color_primaries", "bt709",
        # Ëâ≤ÂΩ©‰º†ËæìÁâπÊÄßÔºöBT.709‰ºΩÈ©¨Êõ≤Á∫ø
        "-color_trc", "bt709",
        # Ëâ≤ÂΩ©Á©∫Èó¥ÔºöBT.709
        "-colorspace", "bt709",
        # RTMPÈááÁî®Áõ¥Êí≠Ê®°Âºè
        "-rtmp_live", "live",
        # RTMPÁºìÂÜ≤Âå∫Â§ßÂ∞è100msÔºåÈôç‰ΩéÂª∂Ëøü
        "-rtmp_buffer", "100",
        # Á¶ÅÊ≠¢ÂÜôÂÖ•Êó∂ÈïøÂíåÊñá‰ª∂Â§ßÂ∞èÂÖÉÊï∞ÊçÆ
        "-flvflags", "no_duration_filesize",
        # ËæìÂá∫Ê†ºÂºè‰∏∫FLV
        "-f", "flv",
        # RTMPËæìÂá∫Âú∞ÂùÄ
        output_url,
    ]

    async with _LOCK:
        await _stop_stream_unlocked(udid)
        try:
            proc = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                limit=_STREAM_READER_LIMIT,
            )
        except FileNotFoundError:
            core.logger.error("\033[1;31müí• FFMPEG ÂèØÊâßË°åÊñá‰ª∂Êú™ÊâæÂà∞\033[0m | Ë∑ØÂæÑ: %s", FFMPEG_BIN)
            return "ffmpeg not found"
        except Exception as exc:  # noqa: BLE001
            core.logger.exception("\033[1;31müí• FFMPEG ÂêØÂä®Â§±Ë¥•\033[0m | ËÆæÂ§á: %s | ÈîôËØØ: %s", udid, str(exc))
            return str(exc)

        reader_task = asyncio.create_task(
            _pump_logs(udid, proc),
            name=f"ffmpeg-log-{udid}",
        )
        _STREAMS[udid] = _StreamState(proc, reader_task)

        # Êé®ÊµÅÂêØÂä®Êó•Âøó - ‰ΩøÁî®ÈÜíÁõÆÁöÑÈ¢úËâ≤ÂíåÂÆåÊï¥‰ø°ÊÅØ
        core.logger.info(
            "\033[1;36müöÄ FFMPEG Êé®ÊµÅÂêØÂä®\033[0m | ËÆæÂ§á: %s | ‰ºöËØù: %s | ËæìÂÖ•: %s | ËæìÂá∫: %s | PID: %s",
            udid,
            session_id,
            input_url,
            output_url,
            proc.pid,
        )

        # ËÆ∞ÂΩïÊé®ÊµÅÂÖ≥ÈîÆÂèÇÊï∞
        core.logger.info(
            "\033[1;36müìä FFMPEG Êé®ÊµÅÂèÇÊï∞\033[0m | ÁõÆÊ†áÂàÜËæ®Áéá: 720x? | Â∏ßÁéá: 25 | Á†ÅÁéá: 2500k | Á°¨‰ª∂Âä†ÈÄü: ÂºÄÂêØ | Ë∞ÉËØïÁ∫ßÂà´: %s",
            _FFMPEG_LOG_LEVEL.upper()
        )

        # Â¶ÇÊûúÂêØÁî®‰∫ÜËØ¶ÁªÜË∞ÉËØïÔºåÊòæÁ§∫È¢ùÂ§ñ‰ø°ÊÅØ
        if _FFMPEG_LOG_LEVEL in {"debug", "trace", "verbose"}:
            core.logger.info(
                "\033[1;33müîç FFMPEG Ë∞ÉËØïÊ®°ÂºèÂ∑≤ÂêØÁî®\033[0m | Êó•ÂøóÁ∫ßÂà´: %s | Â∞ÜÊòæÁ§∫ËØ¶ÁªÜÁöÑÁºñÁ†ÅÂíåÁ°¨‰ª∂Âä†ÈÄü‰ø°ÊÅØ",
                _FFMPEG_LOG_LEVEL.upper()
            )

        # Log the full command - ‰ΩøÁî®INFOÁ∫ßÂà´Á°Æ‰øùÂßãÁªàÊòæÁ§∫
        core.logger.info("\033[1;36müîß FFMPEG ÂÆåÊï¥ÂëΩ‰ª§\033[0m | %s", " ".join(cmd))
    return None


async def stop_stream(udid: str) -> None:
    async with _LOCK:
        await _stop_stream_unlocked(udid)


async def stop_all() -> None:
    async with _LOCK:
        keys = list(_STREAMS.keys())
    for udid in keys:
        await stop_stream(udid)


async def _stop_stream_unlocked(udid: str) -> None:
    state = _STREAMS.pop(udid, None)
    if not state:
        return
    proc = state.process
    task = state.task
    if task:
        task.cancel()
        with contextlib.suppress(asyncio.CancelledError):
            await task
    if proc.returncode is None:
        try:
            proc.terminate()
        except ProcessLookupError:
            pass
        try:
            await asyncio.wait_for(proc.wait(), timeout=5)
        except asyncio.TimeoutError:
            try:
                proc.kill()
            except ProcessLookupError:
                pass
            with contextlib.suppress(asyncio.TimeoutError):
                await asyncio.wait_for(proc.wait(), timeout=3)
    core.logger.info("\033[1;33m‚èπÔ∏è  FFMPEG Êé®ÊµÅÂÅúÊ≠¢\033[0m | ËÆæÂ§á: %s", udid)


async def _pump_logs(
    udid: str,
    proc: asyncio.subprocess.Process,
) -> None:

    # FFmpegÊó•ÂøóÊ∂àÊÅØËøáÊª§Ê®°Âºè
    ERROR_PATTERNS = [
        b"error", b"Error", b"ERROR",
        b"failed", b"Failed", b"FAILED",
        b"invalid", b"Invalid", b"INVALID",
        b"timeout", b"Timeout", b"TIMEOUT",
        b"connection", b"Connection", b"CONNECTION",
        b"not found", b"Not found", b"NOT FOUND",
        b"permission", b"Permission", b"PERMISSION",
        b"cannot", b"Cannot", b"CANNOT",
        b"unable", b"Unable", b"UNABLE",
        b"broken", b"Broken", b"BROKEN",
        b"corrupt", b"Corrupt", b"CORRUPT",
    ]

    WARNING_PATTERNS = [
        b"warning", b"Warning", b"WARNING",
        b"deprecated", b"Deprecated", b"DEPRECATED",
        b"unknown", b"Unknown", b"UNKNOWN",
    ]

    INFO_PATTERNS = [
        b"Stream #", b"frame=", b"fps=", b"q=", b"size=", b"time=", b"bitrate=",
        b"starting", b"Starting", b"STARTING",
        b"stopped", b"Stopped", b"STOPPED",
        b"initialized", b"Initialized", b"INITIALIZED",
        b"Encoder:", b"decoder", b"Detected",
        b"Input #", b"Output #",
        b"Successfully", b"Completed", b"Finished",
        b"Connected", b"Streaming", b"Recording",
        b"Using cpu capabilities", b"libx264", b"h264_videotoolbox",
        b"Selected hardware acceleration", b"Hardware acceleration",
    ]

    def _should_log_as_error(line: bytes) -> bool:
        return any(pattern in line for pattern in ERROR_PATTERNS)

    def _should_log_as_warning(line: bytes) -> bool:
        return any(pattern in line for pattern in WARNING_PATTERNS)

    def _should_log_as_info(line: bytes) -> bool:
        return any(pattern in line for pattern in INFO_PATTERNS)

    async def _read(stream, prefix):
        if stream is None:
            return
        buffer = bytearray()

        def _emit(raw: bytes, *, truncated: bool = False) -> None:
            text = raw.decode(errors="ignore").rstrip()
            if truncated:
                text = f"{text} [truncated]"

            # Ê†πÊçÆÂÜÖÂÆπÂÜ≥ÂÆöÊó•ÂøóÁ∫ßÂà´ÂíåÊ†ºÂºè
            if _should_log_as_error(raw):
                core.logger.error("\033[1;31mFFMPEG\033[0m [%s %s] %s", udid, prefix, text)
            elif _should_log_as_warning(raw):
                core.logger.warning("\033[1;33mFFMPEG\033[0m [%s %s] %s", udid, prefix, text)
            elif _should_log_as_info(raw):
                core.logger.info("\033[1;36mFFMPEG\033[0m [%s %s] %s", udid, prefix, text)
            # ÂÖ∂‰ªñÊó•ÂøóÂè™Âú®Ë∞ÉËØïÊ®°Âºè‰∏ãËæìÂá∫
            elif core.logger.isEnabledFor(10):  # DEBUG level
                core.logger.debug("\033[1;90mFFMPEG\033[0m [%s %s] %s", udid, prefix, text)

        while True:
            chunk = await stream.read(_STREAM_READ_CHUNK)
            if not chunk:
                if buffer:
                    _emit(bytes(buffer))
                break
            buffer.extend(chunk)

            while True:
                newline_index = buffer.find(b"\n")
                if newline_index == -1:
                    if len(buffer) >= _STREAM_LOG_MAX_SEGMENT:
                        segment = bytes(buffer[:_STREAM_LOG_MAX_SEGMENT])
                        del buffer[:_STREAM_LOG_MAX_SEGMENT]
                        _emit(segment, truncated=True)
                    break

                line = bytes(buffer[:newline_index])
                del buffer[: newline_index + 1]
                _emit(line)

    try:
        await asyncio.gather(_read(proc.stdout, "stdout"), _read(proc.stderr, "stderr"))
        return_code = await proc.wait()
        if return_code != 0:
            core.logger.error("\033[1;31müí• FFMPEG ËøõÁ®ãÂºÇÂ∏∏ÈÄÄÂá∫\033[0m | ËÆæÂ§á: %s | ÈÄÄÂá∫Á†Å: %d", udid, return_code)
        else:
            core.logger.info("\033[1;32m‚úÖ FFMPEG ËøõÁ®ãÊ≠£Â∏∏ÂÆåÊàê\033[0m | ËÆæÂ§á: %s", udid)
    except asyncio.CancelledError:
        core.logger.debug("\033[1;90mFFMPEG\033[0m Êó•ÂøóÊ≥µÂ∑≤ÂèñÊ∂à | ËÆæÂ§á: %s", udid)
        raise
    except Exception:
        core.logger.exception("\033[1;31müí• FFMPEG Êó•ÂøóÊ≥µÂºÇÂ∏∏\033[0m | ËÆæÂ§á: %s", udid)
    finally:
        pass


def _build_mjpeg_url(base_url: str, port: int) -> str:
    parsed = urlparse(base_url)
    host = parsed.hostname or "127.0.0.1"
    scheme = parsed.scheme or "http"
    return f"{scheme}://{host}:{port}"
